#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/clocks.h"
#include "pio_config.h"
#include "hardware/pwm.h"
#include "pico/bootrom.h"
#include "ws2812.pio.h"
#include "libs/numeros.c"//arquivos para implementação dos numeros
#include "libs/definicoes.h"//arquivos para variaveis globais
#include "libs/debounce.c"//arquivos para debounce
#include <stdlib.h>
#include "hardware/i2c.h"
#include "ssd1306.h"
#include "font.h"
#include "pico/bootrom.h"
#include "hardware/adc.h"

#define I2C_PORT i2c1
#define I2C_SDA 14
#define I2C_SCL 15
#define endereco 0x3C
#define JOYSTICK_X_PIN 26  // GPIO para eixo X
#define JOYSTICK_Y_PIN 27  // GPIO para eixo Y
#define JOYSTICK_PB 22     // GPIO para botão do Joystick
#define Botao_A 5          // GPIO para botão A

// Definições para os LEDs RGB
#define LED_RED_PIN 16
#define LED_GREEN_PIN 17
#define LED_BLUE_PIN 18

// Definições para o display
#define WIDTH 128
#define HEIGHT 64
#define SQUARE_SIZE 8

// Definições para o joystick
#define JOYSTICK_CENTER 2048
#define JOYSTICK_MAX 4095

// Função para configurar o PWM
void setup_pwm(uint pin) {
    gpio_set_function(pin, GPIO_FUNC_PWM);
    uint slice_num = pwm_gpio_to_slice_num(pin);
    pwm_set_wrap(slice_num, JOYSTICK_MAX);
    pwm_set_enabled(slice_num, true);
}

// Função para definir o duty cycle do PWM
void set_pwm_duty(uint pin, uint16_t duty) {
    uint slice_num = pwm_gpio_to_slice_num(pin);
    uint channel = pwm_gpio_to_channel(pin);
    pwm_set_chan_level(slice_num, channel, duty);
}

// Função para ler o valor do joystick
uint16_t read_joystick(uint pin) {
    adc_select_input(pin - 26);
    return adc_read();
}

// Função para desenhar um quadrado no display
void draw_square(ssd1306_t *disp, int x, int y) {
    ssd1306_fill(disp, false); // Limpa o display
    ssd1306_rect(disp, x, y, SQUARE_SIZE, SQUARE_SIZE, true,true); // Desenha o quadrado
    ssd1306_send_data(disp); // Atualiza o display
}

int main() {
    // Inicialização do hardware
    stdio_init_all();
    adc_init();
    adc_gpio_init(JOYSTICK_X_PIN);
    adc_gpio_init(JOYSTICK_Y_PIN);

    // Configuração dos LEDs RGB
    setup_pwm(LED_RED_PIN);
    setup_pwm(LED_GREEN_PIN);
    setup_pwm(LED_BLUE_PIN);

    // Inicialização do display SSD1306
    i2c_init(I2C_PORT, 400 * 1000);
    gpio_set_function(I2C_SDA, GPIO_FUNC_I2C);
    gpio_set_function(I2C_SCL, GPIO_FUNC_I2C);
    gpio_pull_up(I2C_SDA);
    gpio_pull_up(I2C_SCL);

    ssd1306_t ssd;
    ssd1306_init(&ssd, WIDTH, HEIGHT, false, endereco, I2C_PORT);
    ssd1306_config(&ssd);
    ssd1306_fill(&ssd, false); // Limpa o display inicialmente
    ssd1306_send_data(&ssd);

    // Posição inicial do quadrado
    int square_x = (WIDTH - SQUARE_SIZE)/2;
    int square_y = (HEIGHT - SQUARE_SIZE)/2;

 
    
    while (true) {   
        // Leitura dos valores do joystick
        uint16_t x_value = read_joystick(JOYSTICK_X_PIN);
        uint16_t y_value = read_joystick(JOYSTICK_Y_PIN);

        // Cálculo da diferença em relação ao centro
        int16_t x_diff = x_value - JOYSTICK_CENTER;
        int16_t y_diff = y_value - JOYSTICK_CENTER;

        // Controle da intensidade dos LEDs RGB
        set_pwm_duty(LED_RED_PIN, abs(x_diff) * 2); // LED Vermelho controlado pelo eixo X
        set_pwm_duty(LED_BLUE_PIN, abs(y_diff) * 2); // LED Azul controlado pelo eixo Y

         // Movimentação do quadrado no display com base no joystick
         if (x_diff < -512) {
            square_x -= 4;  // Movendo para a esquerda
        } else if (x_diff > 512) {
            square_x += 4;  // Movendo para a direita
        }

        if (y_diff < -512) {
            square_y -= 4;  // Movendo para cima
        } else if (y_diff > 512) {
            square_y += 4;  // Movendo para baixo
        }
        
        // Limites para o quadrado não sair do display
        if (square_x < 0) square_x = 0;
        if (square_x > HEIGHT - SQUARE_SIZE) square_x = HEIGHT- SQUARE_SIZE;
        if (square_y < 0) square_y = 0;
        if (square_y > WIDTH - SQUARE_SIZE) square_y = WIDTH  - SQUARE_SIZE;

        // Desenha o quadrado na nova posição
        draw_square(&ssd, square_x, square_y);
        
      
    

        // Pequeno delay para evitar atualizações muito rápidas
        sleep_ms(20);
    }

    return 0;
}