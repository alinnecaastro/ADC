#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/clocks.h"
#include "pio_config.h"
#include "hardware/pwm.h"
#include "pico/bootrom.h"
#include "ws2812.pio.h"
#include "libs/numeros.c"//arquivos para implementação dos numeros
#include "libs/definicoes.h"//arquivos para variaveis globais
#include "libs/debounce.c"//arquivos para debounce
#include <stdlib.h>
#include "hardware/i2c.h"
#include "ssd1306.h"
#include "font.h"
#include "pico/bootrom.h"
#include "hardware/adc.h"

#define JOYSTICK_X_PIN 26  // Pino ADC conectado ao eixo Y do joystick
#define JOYSTICK_Y_PIN 27  // Pino ADC conectado ao eixo Y do joystick
#define BUTTON_PIN 22
#define LED_GREEN_PIN 11
#define LED_BLUE_PIN 12   // Pino PWM conectado ao LED Azul
#define LED_RED_PIN 13   // Pino PWM conectado ao LED Azul
#define CENTER_VALUE 2048
#define DEADZONE 110
#define BUTTON_A_PIN  5

// Definições do display SSD1306
#define SSD1306_WIDTH 128   // Largura do display
#define SSD1306_HEIGHT 64   // Altura do display
#define SQUARE_SIZE 8       // Tamanho do quadrado (8x8 pixels)
#define I2C_SDA_PIN 14   // Pino SDA do I2C
#define I2C_SCL_PIN 15     // Pino SCL do I2C


// Variáveis de estado
bool led_green_state = false;       // Estado do LED Verde
bool pwm_leds_enabled = true;       // Estado dos LEDs PWM (Vermelho e Azul)
uint8_t border_style = 0;           // Estilo da borda do display (0, 1, 2, ...)



// Função para alternar o LED Verde e a borda do display
void joystick_button_pressed() {
    static uint32_t last_press_time = 0;  // Armazena o tempo do último pressionamento
    uint32_t current_time = to_ms_since_boot(get_absolute_time());

    // Debounce: ignora pressionamentos muito rápidos
    if (current_time - last_press_time > 200) {  // 200 ms de debounce
        led_green_state = !led_green_state;      // Alterna o estado do LED Verde
        gpio_put(LED_GREEN_PIN, led_green_state); // Atualiza o estado do LED

        // Alterna o estilo da borda do display
        border_style = (border_style + 1) % 3;  // Cicla entre 0, 1 e 2
        switch (border_style) {
            case 0:
                printf("Borda: Nenhuma\n");
                break;
            case 1:
                printf("Borda: Linha simples\n");
                break;
            case 2:
                printf("Borda: Linha dupla\n");
                break;
        }

        last_press_time = current_time;  // Atualiza o tempo do último pressionamento
    }
}

// Função para ativar/desativar os LEDs PWM
void button_a_pressed() {
    static uint32_t last_press_time = 0;  // Armazena o tempo do último pressionamento
    uint32_t current_time = to_ms_since_boot(get_absolute_time());

    // Debounce: ignora pressionamentos muito rápidos
    if (current_time - last_press_time > 200) {  // 200 ms de debounce
        pwm_leds_enabled = !pwm_leds_enabled;   // Alterna o estado dos LEDs PWM
        if (pwm_leds_enabled) {
            printf("LEDs PWM ativados\n");
        } else {
            printf("LEDs PWM desativados\n");
        }
        last_press_time = current_time;  // Atualiza o tempo do último pressionamento
    }
}

int main() {
    // Inicialização do stdio
    stdio_init_all();
   
    
    // Inicialização do ADC
    adc_init();
    adc_gpio_init(JOYSTICK_X_PIN);  // Configura o pino do eixo X
    adc_gpio_init(JOYSTICK_Y_PIN);  // Configura o pino do eixo Y

    // Inicialização do PWM para o LED Vermelho
    gpio_set_function(LED_RED_PIN, GPIO_FUNC_PWM);
    uint slice_num_red = pwm_gpio_to_slice_num(LED_RED_PIN);
    uint channel_red = pwm_gpio_to_channel(LED_RED_PIN);
    pwm_set_wrap(slice_num_red, 255);  // Define o intervalo do PWM para 8 bits (0-255)
    pwm_set_enabled(slice_num_red, true);
    pwm_set_chan_level(slice_num_red, channel_red, 0);

    // Inicialização do PWM para o LED Azul
    gpio_set_function(LED_BLUE_PIN, GPIO_FUNC_PWM);
    uint slice_num_blue = pwm_gpio_to_slice_num(LED_BLUE_PIN);
    uint channel_blue = pwm_gpio_to_channel(LED_BLUE_PIN);
    pwm_set_wrap(slice_num_blue, 255);  // Define o intervalo do PWM para 8 bits (0-255)
    pwm_set_chan_level(slice_num_blue, channel_blue, 0); 
    pwm_set_enabled(slice_num_blue, true);

    // Inicialização do pino do botão do joystick
    gpio_init(BUTTON_PIN);
    gpio_set_dir(BUTTON_PIN, GPIO_IN);
    gpio_pull_up(BUTTON_PIN);  // Habilita o resistor de pull-up interno

    // Inicialização do pino do botão A
    gpio_init(BUTTON_A_PIN);
    gpio_set_dir(BUTTON_A_PIN, GPIO_IN);
    gpio_pull_up(BUTTON_A_PIN);  // Habilita o resistor de pull-up interno
    gpio_set_irq_enabled_with_callback(BUTTON_PIN_A, GPIO_IRQ_EDGE_FALL, true, &gpio_callback);   

    // Inicialização do pino do LED Verde
    gpio_init(LED_GREEN_PIN);
    gpio_set_dir(LED_GREEN_PIN, GPIO_OUT);
    gpio_put(LED_GREEN_PIN, led_green_state);  // Inicializa o LED Verde como apagado


    while (true) {
        // Leitura do valor do eixo X do joystick (LED Vermelho)
        adc_select_input(1);  // Seleciona o canal ADC 1 (Eixo X)
        uint16_t x_value = adc_read();

        // Leitura do valor do eixo Y do joystick (LED Azul)
        adc_select_input(0);  // Seleciona o canal ADC 0 (Eixo Y)
        uint16_t y_value = adc_read();
        
    

        // Mapeia o valor do eixo X para o brilho do LED Vermelho
        uint8_t brightness_red = 0;
        if (x_value < (CENTER_VALUE - DEADZONE)) {
            // Movendo para a esquerda (valores menores que 2048 - margem)
            brightness_red = (CENTER_VALUE - DEADZONE - x_value) / 8;  // Divide por 8 para mapear de 0-2048 para 0-255
        } else if (x_value > (CENTER_VALUE + DEADZONE)) {
            // Movendo para a direita (valores maiores que 2048 + margem)
            brightness_red = (x_value - (CENTER_VALUE + DEADZONE)) / 8;  // Divide por 8 para mapear de 0-2048 para 0-255
        }
        // Se x_value estiver dentro da margem de erro (centro), brightness_red permanece 0 (LED apagado)

        // Mapeia o valor do eixo Y para o brilho do LED Azul
        uint8_t brightness_blue = 0;
        if (y_value < (CENTER_VALUE - DEADZONE)) {
            // Movendo para cima (valores menores que 2048 - margem)
            brightness_blue = (CENTER_VALUE - DEADZONE - y_value) / 8;  // Divide por 8 para mapear de 0-2048 para 0-255
        } else if (y_value > (CENTER_VALUE + DEADZONE)) {
            // Movendo para baixo (valores maiores que 2048 + margem)
            brightness_blue = (y_value - (CENTER_VALUE + DEADZONE)) / 8;  // Divide por 8 para mapear de 0-2048 para 0-255
        }
        // Se y_value estiver dentro da margem de erro (centro), brightness_blue permanece 0 (LED apagado)

        // Define o ciclo de trabalho do PWM para controlar o brilho dos LEDs
        if (pwm_leds_enabled) {
            pwm_set_gpio_level(LED_RED_PIN, brightness_red);   // LED Vermelho
            pwm_set_gpio_level(LED_BLUE_PIN, brightness_blue); // LED Azul
        } else {
            pwm_set_gpio_level(LED_RED_PIN, 0);  // Desliga o LED Vermelho
            pwm_set_gpio_level(LED_BLUE_PIN, 0); // Desliga o LED Azul
        }

        // Verifica se o botão do joystick foi pressionado
        if (!gpio_get(BUTTON_PIN)) {  // Botão pressionado (nível baixo, pois está com pull-up)
            joystick_button_pressed(); // Chama a função para alternar o LED Verde e a borda do display
        }

        // Verifica se o botão A foi pressionado
        if (!gpio_get(BUTTON_A_PIN)) {  // Botão pressionado (nível baixo, pois está com pull-up)
            button_a_pressed();         // Chama a função para ativar/desativar os LEDs PWM
        }

        // Pequeno delay para evitar leituras muito rápidas
        sleep_ms(10);
    }
}